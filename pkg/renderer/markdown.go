package renderer

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/automationpi/azdocs/pkg/analysis"
	"github.com/automationpi/azdocs/pkg/graph"
	"github.com/automationpi/azdocs/pkg/llm"
)

// Config holds renderer configuration
type Config struct {
	OutputDir    string
	FileName     string
	WithDiagrams bool
	Theme        string
	EnableAI     bool
	OpenAIKey    string
}

// MarkdownRenderer generates Markdown documentation
type MarkdownRenderer struct {
	config    Config
	llmClient *llm.Client
}

// NewMarkdownRenderer creates a new Markdown renderer
func NewMarkdownRenderer(config Config) *MarkdownRenderer {
	llmClient := llm.NewClient(llm.Config{
		Enabled: config.EnableAI,
		APIKey:  config.OpenAIKey,
		Model:   "",
	})

	return &MarkdownRenderer{
		config:    config,
		llmClient: llmClient,
	}
}

// Render generates the Markdown documentation
func (r *MarkdownRenderer) Render(topology *graph.Topology) error {
	if err := os.MkdirAll(r.config.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Load the raw resources data to generate actual documentation
	resourcesPath := "./data/raw/all-resources.json"
	resources, err := r.loadResources(resourcesPath)
	if err != nil {
		// If we can't load resources, generate basic template
		return r.renderBasicTemplate()
	}

	// Generate documentation with actual resources
	content := r.generateDocumentation(resources)

	outputPath := filepath.Join(r.config.OutputDir, r.config.FileName)
	return os.WriteFile(outputPath, []byte(content), 0644)
}

// loadResources loads resources from JSON file
func (r *MarkdownRenderer) loadResources(path string) ([]map[string]interface{}, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var resources []map[string]interface{}
	if err := json.Unmarshal(data, &resources); err != nil {
		return nil, err
	}

	return resources, nil
}

// renderBasicTemplate renders a basic template when no data is available
func (r *MarkdownRenderer) renderBasicTemplate() error {
	content := `<div align="center">
  <img src="../assets/azdoc-logo.png" alt="azdoc" width="200"/>

# Azure Subscription Documentation

</div>

## Overview

This document provides comprehensive documentation for the Azure subscription.

Generated by azdoc.

## Network Topology

<!-- Topology diagrams will be linked here -->

## Resources

<!-- Resource tables will be generated here -->
`

	outputPath := filepath.Join(r.config.OutputDir, r.config.FileName)
	return os.WriteFile(outputPath, []byte(content), 0644)
}

// generateDocumentation generates documentation from resources
func (r *MarkdownRenderer) generateDocumentation(resources []map[string]interface{}) string {
	var content strings.Builder

	// Get AI-generated descriptions if enabled
	var aiDescription *llm.ArchitectureDescription
	if r.llmClient.IsEnabled() {
		fmt.Println("  ü§ñ Generating AI architecture descriptions...")
		ctx := context.Background()
		desc, err := r.llmClient.GenerateArchitectureDescription(ctx, resources)
		if err != nil {
			fmt.Printf("  ‚ö†Ô∏è  AI description generation failed: %v\n", err)
			fmt.Println("  ‚ÑπÔ∏è  Continuing with standard documentation")
		} else {
			aiDescription = desc
			fmt.Println("  ‚úÖ AI descriptions generated successfully")
		}
	}

	// Header with logo
	content.WriteString("<div align=\"center\">\n")
	content.WriteString("  <img src=\"../assets/azdoc-logo.png\" alt=\"azdoc\" width=\"200\"/>\n\n")
	content.WriteString("# Azure Subscription Documentation\n\n")
	content.WriteString("</div>\n\n")
	content.WriteString(fmt.Sprintf("**Generated:** %s\n\n", time.Now().Format(time.RFC3339)))
	content.WriteString(fmt.Sprintf("**Total Resources:** %d\n\n", len(resources)))

	// Group resources by resource group
	resourcesByRG := r.groupResourcesByResourceGroup(resources)
	rgCount := len(resourcesByRG)

	// Run all analyses
	securityAnalysis := analysis.AnalyzeSecurity(resources)
	costAnalysis := analysis.AnalyzeCost(resources)
	taggingAnalysis := analysis.AnalyzeTagging(resources)
	complianceAnalysis := analysis.AnalyzeCompliance(resources)

	// Table of Contents
	content.WriteString("## Table of Contents\n\n")
	content.WriteString("- [Overview](#overview)\n")
	content.WriteString("- [Executive Summary](#executive-summary)\n")
	if aiDescription != nil {
		content.WriteString("- [Key Findings](#key-findings)\n")
	}
	content.WriteString("- [Network Architecture Diagrams](#network-architecture-diagrams)\n")
	content.WriteString("- [IP Address Allocation](#ip-address-allocation)\n")
	content.WriteString("- [Routing Configuration](#routing-configuration)\n")
	content.WriteString("- [Security & Compliance](#security--compliance)\n")
	content.WriteString("- [Cost Optimization](#cost-optimization)\n")
	content.WriteString("- [Tagging Strategy](#tagging-strategy)\n")
	content.WriteString("- [Resource Summary](#resource-summary)\n")
	content.WriteString("- [Resource Groups](#resource-groups)\n")
	for rgName := range resourcesByRG {
		anchor := strings.ReplaceAll(strings.ToLower(rgName), " ", "-")
		content.WriteString(fmt.Sprintf("  - [%s](#%s)\n", rgName, anchor))
	}
	if r.loadRecommendations() != nil && len(r.loadRecommendations()) > 0 {
		content.WriteString("- [Azure Advisor Recommendations](#azure-advisor-recommendations)\n")
	}
	content.WriteString("\n")

	// Overview with AI description
	content.WriteString("## Overview\n\n")
	if aiDescription != nil && aiDescription.Overview != "" {
		content.WriteString(aiDescription.Overview + "\n\n")
	} else {
		content.WriteString("This document provides comprehensive documentation for the Azure subscription.\n\n")
	}
	content.WriteString(fmt.Sprintf("**Resource Groups:** %d | **Total Resources:** %d\n\n", rgCount, len(resources)))
	content.WriteString("Generated by **azdoc** - Azure Documentation Generator")
	if r.llmClient.IsEnabled() {
		content.WriteString(" with AI-enhanced descriptions")
	}
	content.WriteString(".\n\n")

	// Executive Summary Dashboard
	content.WriteString("## Executive Summary\n\n")
	content.WriteString("**Platform Health Dashboard**\n\n")
	content.WriteString("| Category | Status | Score | Key Metrics |\n")
	content.WriteString("|----------|--------|-------|-------------|\n")

	content.WriteString(fmt.Sprintf("| **Security Posture** | %s | %d/100 | %d critical, %d high, %d medium issues |\n",
		securityAnalysis.GetSecurityPosture(),
		securityAnalysis.GetSecurityScore(),
		securityAnalysis.CriticalCount,
		securityAnalysis.HighCount,
		securityAnalysis.MediumCount))

	content.WriteString(fmt.Sprintf("| **Cost Optimization** | %s | %d/100 | $%.0f/month (save $%.0f) |\n",
		costAnalysis.GetCostHealth(),
		costAnalysis.GetCostScore(),
		costAnalysis.TotalMonthlyCost,
		costAnalysis.PotentialMonthlySavings))

	content.WriteString(fmt.Sprintf("| **Tagging Compliance** | %s | %d/100 | %.0f%% tagged, %d untagged resources |\n",
		taggingAnalysis.GetTaggingHealth(),
		taggingAnalysis.GetTaggingScore(),
		taggingAnalysis.ComplianceRate,
		taggingAnalysis.UntaggedResources))

	content.WriteString(fmt.Sprintf("| **DR & Monitoring** | %s | %d/100 | %.0f%% backup, %.0f%% monitoring |\n",
		complianceAnalysis.GetComplianceHealth(),
		complianceAnalysis.GetComplianceScore(),
		complianceAnalysis.BackupCoverage,
		complianceAnalysis.MonitoringCoverage))

	content.WriteString("\n")

	// Top Priority Actions
	content.WriteString("### üéØ Top Priority Actions\n\n")
	priorityActions := r.getPriorityActions(securityAnalysis, costAnalysis, taggingAnalysis, complianceAnalysis)
	for i, action := range priorityActions {
		if i >= 5 {
			break // Show top 5
		}
		content.WriteString(fmt.Sprintf("%d. %s **%s** - %s\n", i+1, action.Icon, action.Title, action.Impact))
	}
	content.WriteString("\n")

	// Key Findings (AI-generated)
	if aiDescription != nil && len(aiDescription.KeyFindings) > 0 {
		content.WriteString("## Key Findings\n\n")
		for i, finding := range aiDescription.KeyFindings {
			content.WriteString(fmt.Sprintf("%d. %s\n", i+1, finding))
		}
		content.WriteString("\n")
	}

	// Network Architecture Diagrams
	content.WriteString("## Network Architecture Diagrams\n\n")
	if r.config.WithDiagrams {
		content.WriteString("Network topology diagrams are generated in the `diagrams/` directory.\n\n")

		// List VNet diagrams
		vnets := r.filterByType(resources, "microsoft.network/virtualnetworks")
		if len(vnets) > 0 {
			content.WriteString("### Virtual Network Diagrams\n\n")
			for _, vnet := range vnets {
				vnetName := r.getString(vnet, "name")
				content.WriteString(fmt.Sprintf("- **[%s](diagrams/%s.drawio)** - ", vnetName, vnetName))

				// Add VNet address space
				if props, ok := vnet["properties"].(map[string]interface{}); ok {
					if addrSpace, ok := props["addressSpace"].(map[string]interface{}); ok {
						if prefixes, ok := addrSpace["addressPrefixes"].([]interface{}); ok && len(prefixes) > 0 {
							content.WriteString(fmt.Sprintf("Address Space: `%v`", prefixes[0]))
						}
					}
				}
				content.WriteString("\n")
			}
			content.WriteString("\n")
		}

		content.WriteString("**[Overview Diagram](diagrams/Overview.drawio)** - Complete architecture overview\n\n")
		content.WriteString("üí° *Open `.drawio` files with [diagrams.net](https://app.diagrams.net) or VS Code with Draw.io Integration extension*\n\n")
	} else {
		content.WriteString("Diagram generation is disabled. Run with `--with-diagrams` to generate visual architecture diagrams.\n\n")
	}

	// IP Address Allocation
	content.WriteString("## IP Address Allocation\n\n")
	r.generateIPAddressTables(&content, resources)

	// Routing Configuration
	content.WriteString("## Routing Configuration\n\n")
	r.generateRoutingTables(&content, resources)

	// Security & Compliance Section
	content.WriteString("## Security & Compliance\n\n")
	r.generateSecuritySection(&content, securityAnalysis)

	// AI-powered security insights (if AI enabled)
	if r.llmClient.IsEnabled() {
		fmt.Println("  ü§ñ Generating AI security insights...")
		ctx := context.Background()
		securityInsights, err := r.llmClient.GenerateSecurityInsights(ctx, securityAnalysis)
		if err != nil {
			fmt.Printf("  ‚ö†Ô∏è  AI security insights failed: %v\n", err)
		} else if len(securityInsights) > 0 {
			fmt.Printf("  ‚úÖ Generated %d AI security insights\n", len(securityInsights))
			// Convert to interface{} for rendering
			var insightsInterface []interface{}
			for _, insight := range securityInsights {
				insightMap := map[string]interface{}{
					"priority":        insight.Priority,
					"severity":        insight.Severity,
					"title":           insight.Title,
					"description":     insight.Description,
					"risk_level":      insight.RiskLevel,
					"impact":          insight.Impact,
					"category":        insight.Category,
					"recommendations": insight.Recommendations,
				}
				insightsInterface = append(insightsInterface, insightMap)
			}
			r.generateAISecurityInsights(&content, insightsInterface)
		}
	}

	// Cost Optimization Section
	content.WriteString("## Cost Optimization\n\n")
	r.generateCostSection(&content, costAnalysis)

	// AI-powered cost insights (if AI enabled)
	if r.llmClient.IsEnabled() {
		fmt.Println("  ü§ñ Generating AI cost optimization insights...")
		ctx := context.Background()
		costInsights, err := r.llmClient.GenerateCostOptimizationInsights(ctx, costAnalysis)
		if err != nil {
			fmt.Printf("  ‚ö†Ô∏è  AI cost insights failed: %v\n", err)
		} else if len(costInsights) > 0 {
			fmt.Printf("  ‚úÖ Generated %d AI cost insights\n", len(costInsights))
			// Convert to interface{} for rendering
			var insightsInterface []interface{}
			for _, insight := range costInsights {
				insightMap := map[string]interface{}{
					"priority":          insight.Priority,
					"title":             insight.Title,
					"description":       insight.Description,
					"estimated_savings": insight.EstimatedSavings,
					"effort":            insight.Effort,
					"category":          insight.Category,
					"recommendations":   insight.Recommendations,
				}
				insightsInterface = append(insightsInterface, insightMap)
			}
			r.generateAICostInsights(&content, insightsInterface)
		}
	}

	// Tagging Strategy Section
	content.WriteString("## Tagging Strategy\n\n")
	r.generateTaggingSection(&content, taggingAnalysis)

	// Resource Summary
	content.WriteString("## Resource Summary\n\n")
	resourcesByType := r.groupResourcesByType(resources)
	content.WriteString("| Resource Type | Count |\n")
	content.WriteString("|---------------|-------|\n")
	for resType, count := range resourcesByType {
		content.WriteString(fmt.Sprintf("| %s | %d |\n", resType, count))
	}
	content.WriteString("\n")

	// Resource Groups Section
	content.WriteString("## Resource Groups\n\n")
	content.WriteString("Resources organized by resource group for better architecture understanding.\n\n")

	for rgName, rgResources := range resourcesByRG {
		content.WriteString(fmt.Sprintf("### %s\n\n", rgName))

		// AI-generated description for this resource group
		if aiDescription != nil && aiDescription.ResourceGroupInsights != nil {
			if insight, ok := aiDescription.ResourceGroupInsights[rgName]; ok && insight != "" {
				content.WriteString(fmt.Sprintf("üí° *%s*\n\n", insight))
			}
		}

		content.WriteString(fmt.Sprintf("**Resources:** %d | **Location:** %s\n\n",
			len(rgResources),
			r.getMostCommonLocation(rgResources)))

		// Resource breakdown by type
		rgResourcesByType := r.groupResourcesByType(rgResources)
		content.WriteString("**Resource Types:**\n")
		for resType, count := range rgResourcesByType {
			content.WriteString(fmt.Sprintf("- %s (%d)\n", resType, count))
		}
		content.WriteString("\n")

		// Detailed resource table
		content.WriteString("| Name | Type | Location |\n")
		content.WriteString("|------|------|----------|\n")
		for _, res := range rgResources {
			name := r.getString(res, "name")
			resType := r.getString(res, "type")
			location := r.getString(res, "location")
			content.WriteString(fmt.Sprintf("| %s | %s | %s |\n", name, resType, location))
		}
		content.WriteString("\n")
	}

	// Quick Network Overview (keeping this for backwards compatibility)
	content.WriteString("## Network Overview\n\n")
	networkResources := r.filterNetworkResources(resources)
	if len(networkResources) > 0 {
		content.WriteString("### Virtual Networks\n\n")
		vnets := r.filterByType(networkResources, "microsoft.network/virtualnetworks")
		if len(vnets) > 0 {
			content.WriteString("| Name | Location | Resource Group |\n")
			content.WriteString("|------|----------|----------------|\n")
			for _, vnet := range vnets {
				name := r.getString(vnet, "name")
				location := r.getString(vnet, "location")
				rg := r.getString(vnet, "resourceGroup")
				content.WriteString(fmt.Sprintf("| %s | %s | %s |\n", name, location, rg))
			}
			content.WriteString("\n")
		}

		content.WriteString("### Network Security Groups\n\n")
		nsgs := r.filterByType(networkResources, "microsoft.network/networksecuritygroups")
		if len(nsgs) > 0 {
			content.WriteString("| Name | Location | Resource Group | Tags |\n")
			content.WriteString("|------|----------|----------------|------|\n")
			for _, nsg := range nsgs {
				name := r.getString(nsg, "name")
				location := r.getString(nsg, "location")
				rg := r.getString(nsg, "resourceGroup")
				tags := r.getTags(nsg)
				content.WriteString(fmt.Sprintf("| %s | %s | %s | %s |\n", name, location, rg, tags))
			}
			content.WriteString("\n")
		}

		content.WriteString("### Route Tables\n\n")
		rts := r.filterByType(networkResources, "microsoft.network/routetables")
		if len(rts) > 0 {
			content.WriteString("| Name | Location | Resource Group |\n")
			content.WriteString("|------|----------|----------------|\n")
			for _, rt := range rts {
				name := r.getString(rt, "name")
				location := r.getString(rt, "location")
				rg := r.getString(rt, "resourceGroup")
				content.WriteString(fmt.Sprintf("| %s | %s | %s |\n", name, location, rg))
			}
			content.WriteString("\n")
		}

		content.WriteString("### Load Balancers\n\n")
		lbs := r.filterByType(networkResources, "microsoft.network/loadbalancers")
		if len(lbs) > 0 {
			content.WriteString("| Name | Location | Resource Group |\n")
			content.WriteString("|------|----------|----------------|\n")
			for _, lb := range lbs {
				name := r.getString(lb, "name")
				location := r.getString(lb, "location")
				rg := r.getString(lb, "resourceGroup")
				content.WriteString(fmt.Sprintf("| %s | %s | %s |\n", name, location, rg))
			}
			content.WriteString("\n")
		}

		content.WriteString("### NAT Gateways\n\n")
		nats := r.filterByType(networkResources, "microsoft.network/natgateways")
		if len(nats) > 0 {
			content.WriteString("| Name | Location | Resource Group |\n")
			content.WriteString("|------|----------|----------------|\n")
			for _, nat := range nats {
				name := r.getString(nat, "name")
				location := r.getString(nat, "location")
				rg := r.getString(nat, "resourceGroup")
				content.WriteString(fmt.Sprintf("| %s | %s | %s |\n", name, location, rg))
			}
			content.WriteString("\n")
		}

		content.WriteString("### Public IP Addresses\n\n")
		pips := r.filterByType(networkResources, "microsoft.network/publicipaddresses")
		if len(pips) > 0 {
			content.WriteString("| Name | Location | Resource Group |\n")
			content.WriteString("|------|----------|----------------|\n")
			for _, pip := range pips {
				name := r.getString(pip, "name")
				location := r.getString(pip, "location")
				rg := r.getString(pip, "resourceGroup")
				content.WriteString(fmt.Sprintf("| %s | %s | %s |\n", name, location, rg))
			}
			content.WriteString("\n")
		}
	}

	// Azure Advisor Recommendations with AI Remediation
	recommendations := r.loadRecommendations()
	if len(recommendations) > 0 {
		content.WriteString("## Azure Advisor Recommendations\n\n")
		content.WriteString(fmt.Sprintf("Found **%d recommendations** from Azure Advisor.\n\n", len(recommendations)))

		// Get AI-generated remediation steps if enabled
		var aiRemediations []llm.RecommendationWithRemediation
		if r.llmClient.IsEnabled() {
			fmt.Println("  ü§ñ Generating AI remediation steps for recommendations...")
			ctx := context.Background()
			remediations, err := r.llmClient.GenerateRemediationSteps(ctx, recommendations)
			if err != nil {
				fmt.Printf("  ‚ö†Ô∏è  AI remediation generation failed: %v\n", err)
			} else {
				aiRemediations = remediations
				fmt.Printf("  ‚úÖ Generated remediation steps for %d recommendations\n", len(aiRemediations))
			}
		}

		// Group by category
		recsByCategory := r.groupRecommendationsByCategory(recommendations)

		for category, recs := range recsByCategory {
			content.WriteString(fmt.Sprintf("### %s (%d)\n\n", category, len(recs)))

			for i, rec := range recs {
				// Basic recommendation info
				problem := r.getStringFromMap(rec, "problem")
				solution := r.getStringFromMap(rec, "solution")
				impact := r.getStringFromMap(rec, "impact")
				impactedValue := r.getStringFromMap(rec, "impactedValue")

				content.WriteString(fmt.Sprintf("#### %d. %s\n\n", i+1, problem))
				content.WriteString(fmt.Sprintf("**Impact:** %s", impact))
				if impactedValue != "" {
					content.WriteString(fmt.Sprintf(" | **Resource:** %s", impactedValue))
				}
				content.WriteString("\n\n")
				content.WriteString(fmt.Sprintf("**Azure Recommendation:** %s\n\n", solution))

				// AI-generated remediation steps
				if len(aiRemediations) > i && aiRemediations[i].RemediationSteps != nil {
					remediation := aiRemediations[i]
					content.WriteString("**ü§ñ AI-Generated Remediation Steps:**\n\n")

					if len(remediation.PreRequisites) > 0 {
						content.WriteString("*Prerequisites:*\n")
						for _, prereq := range remediation.PreRequisites {
							content.WriteString(fmt.Sprintf("- %s\n", prereq))
						}
						content.WriteString("\n")
					}

					for _, step := range remediation.RemediationSteps {
						content.WriteString(fmt.Sprintf("%d. **%s**\n", step.Step, step.Action))
						if step.Description != "" {
							content.WriteString(fmt.Sprintf("   - %s\n", step.Description))
						}
						if step.Command != "" {
							content.WriteString(fmt.Sprintf("   ```bash\n   %s\n   ```\n", step.Command))
						}
					}

					if remediation.ValidationCommand != "" {
						content.WriteString(fmt.Sprintf("\n*Validation:*\n```bash\n%s\n```\n", remediation.ValidationCommand))
					}

					if remediation.EstimatedTime != "" {
						content.WriteString(fmt.Sprintf("\n‚è±Ô∏è *Estimated time: %s*\n", remediation.EstimatedTime))
					}
				}

				content.WriteString("\n---\n\n")
			}
		}
	}

	// Footer
	content.WriteString("---\n\n")
	content.WriteString("*Generated by [azdoc](https://github.com/automationpi/azdocs)")
	if r.llmClient.IsEnabled() {
		content.WriteString(" with AI-enhanced insights*\n")
	} else {
		content.WriteString("*\n")
	}

	return content.String()
}

// Helper functions
func (r *MarkdownRenderer) groupResourcesByType(resources []map[string]interface{}) map[string]int {
	counts := make(map[string]int)
	for _, res := range resources {
		if resType, ok := res["type"].(string); ok {
			counts[resType]++
		}
	}
	return counts
}

func (r *MarkdownRenderer) filterNetworkResources(resources []map[string]interface{}) []map[string]interface{} {
	var filtered []map[string]interface{}
	for _, res := range resources {
		if resType, ok := res["type"].(string); ok {
			if strings.HasPrefix(strings.ToLower(resType), "microsoft.network") {
				filtered = append(filtered, res)
			}
		}
	}
	return filtered
}

func (r *MarkdownRenderer) filterByType(resources []map[string]interface{}, resourceType string) []map[string]interface{} {
	var filtered []map[string]interface{}
	for _, res := range resources {
		if resType, ok := res["type"].(string); ok {
			if strings.ToLower(resType) == strings.ToLower(resourceType) {
				filtered = append(filtered, res)
			}
		}
	}
	return filtered
}

func (r *MarkdownRenderer) getString(resource map[string]interface{}, key string) string {
	if val, ok := resource[key].(string); ok {
		return val
	}
	return ""
}

func (r *MarkdownRenderer) getTags(resource map[string]interface{}) string {
	if tags, ok := resource["tags"].(map[string]interface{}); ok {
		if len(tags) == 0 {
			return "-"
		}
		var tagStrs []string
		for k, v := range tags {
			tagStrs = append(tagStrs, fmt.Sprintf("%s=%v", k, v))
		}
		return strings.Join(tagStrs, ", ")
	}
	return "-"
}

func (r *MarkdownRenderer) groupResourcesByResourceGroup(resources []map[string]interface{}) map[string][]map[string]interface{} {
	groups := make(map[string][]map[string]interface{})
	for _, res := range resources {
		if rg, ok := res["resourceGroup"].(string); ok {
			groups[rg] = append(groups[rg], res)
		}
	}
	return groups
}

func (r *MarkdownRenderer) getMostCommonLocation(resources []map[string]interface{}) string {
	locations := make(map[string]int)
	for _, res := range resources {
		if loc, ok := res["location"].(string); ok && loc != "" {
			locations[loc]++
		}
	}

	mostCommon := "N/A"
	maxCount := 0
	for loc, count := range locations {
		if count > maxCount {
			mostCommon = loc
			maxCount = count
		}
	}
	return mostCommon
}

func (r *MarkdownRenderer) loadRecommendations() []interface{} {
	data, err := os.ReadFile("./data/raw/recommendations.json")
	if err != nil {
		return []interface{}{}
	}

	var recommendations []interface{}
	if err := json.Unmarshal(data, &recommendations); err != nil {
		return []interface{}{}
	}

	return recommendations
}

func (r *MarkdownRenderer) groupRecommendationsByCategory(recommendations []interface{}) map[string][]map[string]interface{} {
	groups := make(map[string][]map[string]interface{})

	for _, rec := range recommendations {
		if recMap, ok := rec.(map[string]interface{}); ok {
			category := r.getStringFromMap(recMap, "category")
			if category == "" {
				category = "Other"
			}
			groups[category] = append(groups[category], recMap)
		}
	}

	return groups
}

func (r *MarkdownRenderer) getStringFromMap(m map[string]interface{}, key string) string {
	if val, ok := m[key].(string); ok {
		return val
	}
	return ""
}

// generateIPAddressTables generates IP address allocation tables
func (r *MarkdownRenderer) generateIPAddressTables(content *strings.Builder, resources []map[string]interface{}) {
	// VNet Address Spaces
	vnets := r.filterByType(resources, "microsoft.network/virtualnetworks")
	if len(vnets) > 0 {
		content.WriteString("### Virtual Network Address Spaces\n\n")
		content.WriteString("| VNet | Address Space | Subnets | Location |\n")
		content.WriteString("|------|---------------|---------|----------|\n")

		for _, vnet := range vnets {
			vnetName := r.getString(vnet, "name")
			location := r.getString(vnet, "location")
			addressSpace := "N/A"
			subnetCount := 0

			if props, ok := vnet["properties"].(map[string]interface{}); ok {
				// Get address space
				if addrSpace, ok := props["addressSpace"].(map[string]interface{}); ok {
					if prefixes, ok := addrSpace["addressPrefixes"].([]interface{}); ok && len(prefixes) > 0 {
						var spaces []string
						for _, prefix := range prefixes {
							spaces = append(spaces, fmt.Sprintf("%v", prefix))
						}
						addressSpace = strings.Join(spaces, ", ")
					}
				}

				// Count subnets
				if subnets, ok := props["subnets"].([]interface{}); ok {
					subnetCount = len(subnets)
				}
			}

			content.WriteString(fmt.Sprintf("| %s | `%s` | %d | %s |\n", vnetName, addressSpace, subnetCount, location))
		}
		content.WriteString("\n")

		// Subnet Details
		content.WriteString("### Subnet Allocation\n\n")
		for _, vnet := range vnets {
			vnetName := r.getString(vnet, "name")

			if props, ok := vnet["properties"].(map[string]interface{}); ok {
				if subnets, ok := props["subnets"].([]interface{}); ok && len(subnets) > 0 {
					content.WriteString(fmt.Sprintf("**%s:**\n\n", vnetName))
					content.WriteString("| Subnet | Address Prefix | Available IPs | NSG | Route Table |\n")
					content.WriteString("|--------|----------------|---------------|-----|-------------|\n")

					for _, subnetIface := range subnets {
						if subnet, ok := subnetIface.(map[string]interface{}); ok {
							subnetName := "N/A"
							addressPrefix := "N/A"
							nsg := "-"
							routeTable := "-"

							if name, ok := subnet["name"].(string); ok {
								subnetName = name
							}

							if subnetProps, ok := subnet["properties"].(map[string]interface{}); ok {
								if prefix, ok := subnetProps["addressPrefix"].(string); ok {
									addressPrefix = prefix
								}

								// NSG association
								if nsgRef, ok := subnetProps["networkSecurityGroup"].(map[string]interface{}); ok {
									if id, ok := nsgRef["id"].(string); ok {
										nsg = extractResourceName(id)
									}
								}

								// Route table association
								if rtRef, ok := subnetProps["routeTable"].(map[string]interface{}); ok {
									if id, ok := rtRef["id"].(string); ok {
										routeTable = extractResourceName(id)
									}
								}
							}

							// Calculate available IPs
							availableIPs := calculateAvailableIPs(addressPrefix)

							content.WriteString(fmt.Sprintf("| %s | `%s` | ~%d | %s | %s |\n",
								subnetName, addressPrefix, availableIPs, nsg, routeTable))
						}
					}
					content.WriteString("\n")
				}
			}
		}
	}

	// Public IP Addresses
	pips := r.filterByType(resources, "microsoft.network/publicipaddresses")
	if len(pips) > 0 {
		content.WriteString("### Public IP Addresses\n\n")
		content.WriteString("| Name | IP Address | Allocation | SKU | Location |\n")
		content.WriteString("|------|------------|------------|-----|----------|\n")

		for _, pip := range pips {
			pipName := r.getString(pip, "name")
			location := r.getString(pip, "location")
			ipAddress := "Dynamic"
			allocation := "Dynamic"
			sku := "Basic"

			if props, ok := pip["properties"].(map[string]interface{}); ok {
				if ip, ok := props["ipAddress"].(string); ok && ip != "" {
					ipAddress = ip
				}
				if alloc, ok := props["publicIPAllocationMethod"].(string); ok {
					allocation = alloc
				}
			}

			if skuObj, ok := pip["sku"].(map[string]interface{}); ok {
				if skuName, ok := skuObj["name"].(string); ok {
					sku = skuName
				}
			}

			content.WriteString(fmt.Sprintf("| %s | `%s` | %s | %s | %s |\n",
				pipName, ipAddress, allocation, sku, location))
		}
		content.WriteString("\n")
	}

	// Network Interfaces with Private IPs
	nics := r.filterByType(resources, "microsoft.network/networkinterfaces")
	if len(nics) > 0 {
		content.WriteString("### Network Interface Private IPs\n\n")
		content.WriteString("| NIC | Private IP | Allocation | Subnet | VM/Resource |\n")
		content.WriteString("|-----|------------|------------|--------|-------------|\n")

		for _, nic := range nics {
			nicName := r.getString(nic, "name")
			privateIP := "N/A"
			allocation := "Dynamic"
			subnet := "N/A"
			vm := "-"

			if props, ok := nic["properties"].(map[string]interface{}); ok {
				// Get IP configurations
				if ipConfigs, ok := props["ipConfigurations"].([]interface{}); ok && len(ipConfigs) > 0 {
					if ipConfig, ok := ipConfigs[0].(map[string]interface{}); ok {
						if ipProps, ok := ipConfig["properties"].(map[string]interface{}); ok {
							if ip, ok := ipProps["privateIPAddress"].(string); ok {
								privateIP = ip
							}
							if alloc, ok := ipProps["privateIPAllocationMethod"].(string); ok {
								allocation = alloc
							}
							if subnetRef, ok := ipProps["subnet"].(map[string]interface{}); ok {
								if id, ok := subnetRef["id"].(string); ok {
									subnet = extractResourceName(id)
								}
							}
						}
					}
				}

				// Get attached VM
				if vmRef, ok := props["virtualMachine"].(map[string]interface{}); ok {
					if id, ok := vmRef["id"].(string); ok {
						vm = extractResourceName(id)
					}
				}
			}

			content.WriteString(fmt.Sprintf("| %s | `%s` | %s | %s | %s |\n",
				nicName, privateIP, allocation, subnet, vm))
		}
		content.WriteString("\n")
	}
}

// generateRoutingTables generates routing configuration tables
func (r *MarkdownRenderer) generateRoutingTables(content *strings.Builder, resources []map[string]interface{}) {
	// Route Tables
	routeTables := r.filterByType(resources, "microsoft.network/routetables")
	if len(routeTables) > 0 {
		content.WriteString("### Route Tables\n\n")

		for _, rt := range routeTables {
			rtName := r.getString(rt, "name")
			location := r.getString(rt, "location")

			content.WriteString(fmt.Sprintf("#### %s (%s)\n\n", rtName, location))

			if props, ok := rt["properties"].(map[string]interface{}); ok {
				if routes, ok := props["routes"].([]interface{}); ok && len(routes) > 0 {
					content.WriteString("| Route Name | Address Prefix | Next Hop Type | Next Hop IP |\n")
					content.WriteString("|------------|----------------|---------------|-------------|\n")

					for _, routeIface := range routes {
						if route, ok := routeIface.(map[string]interface{}); ok {
							routeName := "N/A"
							addressPrefix := "N/A"
							nextHopType := "N/A"
							nextHopIP := "-"

							if name, ok := route["name"].(string); ok {
								routeName = name
							}

							if routeProps, ok := route["properties"].(map[string]interface{}); ok {
								if prefix, ok := routeProps["addressPrefix"].(string); ok {
									addressPrefix = prefix
								}
								if hopType, ok := routeProps["nextHopType"].(string); ok {
									nextHopType = hopType
								}
								if hopIP, ok := routeProps["nextHopIpAddress"].(string); ok && hopIP != "" {
									nextHopIP = hopIP
								}
							}

							content.WriteString(fmt.Sprintf("| %s | `%s` | %s | %s |\n",
								routeName, addressPrefix, nextHopType, nextHopIP))
						}
					}
					content.WriteString("\n")
				} else {
					content.WriteString("*No custom routes defined*\n\n")
				}
			}
		}
	} else {
		content.WriteString("No custom route tables configured. Using Azure default system routes.\n\n")
	}

	// VNet Peerings
	vnets := r.filterByType(resources, "microsoft.network/virtualnetworks")
	hasPeerings := false
	for _, vnet := range vnets {
		if props, ok := vnet["properties"].(map[string]interface{}); ok {
			if peerings, ok := props["virtualNetworkPeerings"].([]interface{}); ok && len(peerings) > 0 {
				if !hasPeerings {
					content.WriteString("### VNet Peerings\n\n")
					content.WriteString("| Source VNet | Peered VNet | Status | Allow Forwarded Traffic | Allow Gateway Transit |\n")
					content.WriteString("|-------------|-------------|--------|------------------------|----------------------|\n")
					hasPeerings = true
				}

				vnetName := r.getString(vnet, "name")
				for _, peeringIface := range peerings {
					if peering, ok := peeringIface.(map[string]interface{}); ok {
						peeringName := "N/A"
						status := "N/A"
						allowForwarded := "No"
						allowGateway := "No"

						if name, ok := peering["name"].(string); ok {
							peeringName = name
						}

						if peeringProps, ok := peering["properties"].(map[string]interface{}); ok {
							if state, ok := peeringProps["peeringState"].(string); ok {
								status = state
							}
							if fwd, ok := peeringProps["allowForwardedTraffic"].(bool); ok && fwd {
								allowForwarded = "Yes"
							}
							if gw, ok := peeringProps["allowGatewayTransit"].(bool); ok && gw {
								allowGateway = "Yes"
							}
						}

						content.WriteString(fmt.Sprintf("| %s | %s | %s | %s | %s |\n",
							vnetName, peeringName, status, allowForwarded, allowGateway))
					}
				}
			}
		}
	}

	if hasPeerings {
		content.WriteString("\n")
	}
}

// Helper function to extract resource name from resource ID
func extractResourceName(resourceID string) string {
	parts := strings.Split(resourceID, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return resourceID
}

// Helper function to calculate available IPs in a subnet
func calculateAvailableIPs(cidr string) int {
	if cidr == "" || cidr == "N/A" {
		return 0
	}

	parts := strings.Split(cidr, "/")
	if len(parts) != 2 {
		return 0
	}

	var prefixLen int
	fmt.Sscanf(parts[1], "%d", &prefixLen)

	if prefixLen < 0 || prefixLen > 32 {
		return 0
	}

	totalIPs := 1 << (32 - prefixLen)
	// Azure reserves 5 IPs per subnet
	return totalIPs - 5
}
